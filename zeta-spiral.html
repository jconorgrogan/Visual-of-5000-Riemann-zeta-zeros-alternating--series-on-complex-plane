<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Zeta Partial Sums — Multi-Prime Visualizer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/big.js/6.1.1/big.min.js"></script>
  <style>
    :root { --bg:#f8f9fb; --ink:#111; --ink2:#333; --panel:#ffffff; --line:#ddd; }
    body {
      margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, Arial, sans-serif;
      display: grid; place-items: center; min-height: 100vh; gap: 12px;
    }
    .controls {
      display: flex; flex-wrap: wrap; align-items: center; gap: 12px;
      background: var(--panel); border: 1px solid var(--line); padding: 10px 12px; border-radius: 10px;
      max-width: 900px;
    }
    .controls label { font-size: 14px; color: var(--ink2); }
    .controls input[type="range"] { width: 180px; }
    .controls input[type="number"] { width: 80px; padding: 4px; }
    canvas { border: 1px solid #000; background: #fff; }
    .small { font-size: 12px; color: var(--ink2); }
    .spacer { flex: 1; }
    .rotation-panel {
      background: var(--panel); border: 1px solid var(--line); padding: 10px;
      border-radius: 10px; max-width: 900px; max-height: 300px; overflow-y: auto;
      font-size: 12px; font-family: 'Courier New', monospace;
    }
    .rotation-panel table { width: 100%; border-collapse: collapse; }
    .rotation-panel th, .rotation-panel td { padding: 4px 8px; text-align: left; }
    .rotation-panel th { background: var(--line); font-weight: bold; }
    .rotation-panel th[onclick] { cursor: pointer; user-select: none; }
    .rotation-panel th[onclick]:hover { background: #ccc; }
    .rotation-panel tr:nth-child(even) { background: var(--bg); }
    .help-3d {
      font-size: 11px; color: #666; padding: 4px 8px; max-width: 900px;
      background: var(--bg); border: 1px solid var(--line); border-radius: 4px;
      display: none;
    }
  </style>
</head>
<body>
  <div class="controls">
    <label>Speed (FPS):
      <input type="range" id="speedSlider" min="1" max="24" value="24">
      <span id="speedVal" class="small">24</span>
    </label>

    <label>Series Type:
      <select id="seriesType" style="padding: 4px;">
        <option value="1">Standard ζ(s) (p=1)</option>
        <option value="2">Alternating η(s) (p=2)</option>
        <option value="3">p=3 Walk</option>
        <option value="5">p=5 Walk</option>
        <option value="7">p=7 Walk</option>
      </select>
    </label>

    <label><input type="checkbox" id="mode3DToggle"> 3D mode</label>

    <label>Z-axis:
      <select id="zAxisMode" style="padding: 4px;">
        <option value="iteration">Iteration</option>
        <option value="distance">Distance traveled</option>
      </select>
    </label>

    <label><input type="checkbox" id="boldZerosToggle"> Bold zeros</label>

    <label><input type="checkbox" id="flipViewToggle"> Flip view</label>

    <label><input type="checkbox" id="fractionModeToggle"> Fraction mode</label>

    <div id="fractionControls" style="display: none; gap: 8px; align-items: center; flex-wrap: wrap;">
      <label>Re(s):
        <input type="number" id="fractionReal" value="0.5" step="0.01" min="0" max="1" style="width: 55px;">
      </label>

      <label>Im start:
        <input type="number" id="fractionStart" value="0.1" step="any" style="width: 65px;">
      </label>

      <label>Im end:
        <input type="number" id="fractionEnd" value="150" step="any" style="width: 65px;">
      </label>

      <label>Step:
        <input type="number" id="fractionIncrement" value="0.1" step="any" style="width: 60px;">
      </label>

      <button id="applyFractionBtn">Apply</button>
    </div>

    <label><input type="checkbox" id="nonZerosToggle"> Show 10 non-zeros (comparison)</label>

    <label>Abel damping λ:
      <input type="range" id="dampSlider" min="0" max="0.01" value="0" step="0.0005">
      <span id="dampVal" class="small">0.0000</span>
    </label>

    <label>Line thickness:
      <input type="range" id="thicknessSlider" min="0.01" max="5" value="0.01" step="0.01">
      <span id="thicknessVal" class="small">0.01</span>
    </label>

    <label>Opacity:
      <input type="range" id="opacitySlider" min="0.1" max="1" value="0.8" step="0.05">
      <span id="opacityVal" class="small">0.8</span>
    </label>

    <label>Endpoint size:
      <input type="range" id="endpointSlider" min="0" max="15" value="1" step="0.5">
      <span id="endpointVal" class="small">1.0</span>
    </label>

    <label>Number of zeros:
      <input type="number" id="zerosInput" min="1" max="10000" value="5000">
    </label>
    <button id="applyZerosBtn">Apply</button>

    <label>Precompute iterations:
      <input type="range" id="precomputeSlider" min="100" max="5000" value="1000" step="100">
      <span id="precomputeVal" class="small">1000</span>
    </label>
    <button id="precomputeBtn">Cache All</button>

    <label>Custom s = 1/2 + i·t:
      <input type="text" id="customTInput" placeholder="e.g. 14.134725..." style="width: 140px;">
    </label>
    <button id="addCustomBtn">Add</button>

    <label>OR Pick nth zero:
      <input type="number" id="nthZeroInput" placeholder="e.g. 5, 42, 9999" style="width: 100px;" min="1" max="10000">
    </label>
    <button id="addNthBtn">Add nth</button>

    <div class="spacer"></div>

    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
    <button id="pauseBtn">Pause</button>
    <button id="restartBtn">Restart</button>
    <button id="resetBtn">Reset</button>
    <button id="reset3DBtn">Reset 3D View</button>
    <button id="normalizeZBtn">Normalize Z-axis</button>

    <label><input type="checkbox" id="showRotationToggle"> Show rotation metrics</label>
  </div>

  <div id="rotationPanel" class="rotation-panel" style="display: none;"></div>

  <div id="help3D" class="help-3d">
    <strong>3D Controls:</strong> Drag mouse to rotate 360° | Scroll wheel to zoom | Arrow keys for fine rotation | +/- keys for zoom | R key to reset view
  </div>

  <script>
    // --- Non-zero comparison points (interesting points NOT on critical line or not zeros)
    // Mix of: nearby off-line points, golden ratio multiples, π multiples, etc.
    const nonZeroImParts = [
      15.5,           // Near first zero but offset
      22.0,           // Between first and second
      Math.PI * 10,   // π × 10 ≈ 31.4
      40.0,           // Round number
      50.0 + Math.E,  // 50 + e ≈ 52.7
      Math.sqrt(3700), // √3700 ≈ 60.8
      77.7,           // Lucky sevens
      100.0,          // Century mark
      123.456,        // Sequential digits
      200.0 - Math.PI // 200 - π ≈ 196.9
    ];

    // --- Data: First 10000 Riemann zeta zeros (imaginary parts) - accurate to 18+ decimal places
    // Source: Plouffe's database (first 100 at 1000+ digits), extended with Odlyzko tables
    // Using higher precision to reduce phase error for convergence
    const allZeroImParts = [
"14.134725141734693790457252", "21.022039638771554992628480", "25.010857580145688763213791", "30.424876125859513210311898",
      "32.935061587739189690662369", "37.586178158825671257217763", "40.918719012147495187398127", "43.327073280914999519496122",
      "48.005150881167159727942473", "49.773832477672302181916785", "52.970321477714460644147297", "56.446247697063394804367759",
      "59.347044002602353079653649", "60.831778524609809844259902", "65.112544048081606660875054", "67.079810529494173714478829",
      "69.546401711173979252926858", "72.067157674481907582522108", "75.704690699083933168326917", "77.144840068874805372682665",
      "79.337375020249367922763593", "82.910380854086030183164837", "84.735492980517050105735311", "87.425274613125229406531668",
      "88.809111207634465423682348", "92.491899270558484296259725", "94.651344040519886966597926", "95.870634228245309758741029",
      "98.831194218193692233324420", "101.31785100573139122878545", "103.72553804047833941639841", "105.44662305232609449367083",
      "107.16861118427640751512335", "111.02953554316967452465645", "111.87465917699263708561208", "114.32022091545271276589094",
      "116.22668032085755438216080", "118.79078286597621732297914", "121.37012500242064591894553", "122.94682929355258820081746",
      "124.25681855434576718473201", "127.51668387959649512427932", "129.57870419995605098576803", "131.08768853093265672356637",
      "133.49773720299758645013049", "134.75650975337387133132606", "138.11604205453344320019156", "139.73620895212138895045005",
      "141.12370740402112376194035", "143.11184580762063273940512", "146.00098248676551854740251", "147.42276534255960204952119",
      "150.05352042078488035143247", "150.92525761224146676185252", "153.02469381119889619825654", "156.11290929423786756975019",
      "157.59759181759405988753050", "158.84998817142049872417499", "161.18896413759602751943734", "163.03070968718198724331104",
      "165.53706918790041883003892", "167.18443997817451344095776", "169.09451541556882148950587", "169.91197647941169896669984",
      "173.41153651959155295984612", "174.75419152336572581337876", "176.44143429771041888889264", "178.37740777609997728583094",
      "179.91648402025699613934004", "182.20707848436646191540704", "184.87446784838750880096065", "185.59878367770747146652770",
      "187.22892258350185199164154", "189.41615865601693708485229", "192.02665636071378654728363", "193.07972660384570404740221",
      "195.26539667952923532146319", "196.87648184095831694862226", "198.01530967625191242491992", "201.26475194370378873301613",
      "202.49359451414053427768666", "204.18967180310455433071644", "205.39469720216328602521238", "207.90625888780620986150197",
      "209.57650971685625985283564", "211.69086259536530756390749", "213.34791935971266619063912", "214.54704478349142322294420",
      "216.16953850826370026586956", "219.06759634902137898567726", "220.71491883931400336911559", "221.43070555469333873209748",
      "224.00700025460433521172888", "224.98332466958228750378252", "227.42144427967929131046144", "229.33741330552534810776008",
      "231.25018870049916477380619", "231.98723525318024860377167", "233.69340417890830064070449", "236.52422966581620580247551",
      "237.76982048092520400323663", "239.55547757332762874026893", "241.04915779621658641283792", "242.82327193422260001682647",
      "244.07089849707815823681653", "247.13699007489749946755097", "248.10199006014845925676214", "249.57368964470720919232979",
      "251.01494779501600114295416", "253.06998674799947719459901", "255.30625645491402275308649", "256.38071369443447778935838",
      "258.61043949153136820898306", "259.87440698967800035067284", "260.80508450459687018593123", "263.57389390487013223308159",
      "265.55785183887632029247731", "266.61497378150107249572011", "267.92191508282405944037897", "269.97044902399760259469351",
      "271.49405564164499901817942", "273.45960918840328704571425", "275.58749264934384124874070", "276.45204950313293867988734",
      "278.25074352984195449274828", "279.22925092774518922840988", "282.46511476505209623302720", "283.21118573323386742049384",
      "284.83596398090472413315763", "286.66744536300288429284762", "287.91192050142218715525412", "289.57985492921883415273802",
      "291.84629132906739583551305", "293.55843413935628535677670", "294.96536961926554217506645", "295.57325487895829238846083",
      "297.97927706194341520992968", "299.84032605372131296002705", "301.64932546219418362347010", "302.69674958960691705175148",
      "304.86437134085729770014875", "305.72891260203680928922282", "307.21949612817005478941003", "310.10946314670189880478622",
      "311.16514153035600327094267", "312.42780118060089198048598", "313.98528573115892297904897", "315.47561608947573386859608",
      "317.73480594237018039564549", "318.85310425631659790668918", "321.16013430911357829192147", "322.14455867248293229883745",
      "323.46696955751205050621203", "324.86286605173961326498009", "327.44390126190545734346926", "329.03307168048093403361473",
      "329.95323972823386634389212", "331.47446758266342437566175", "333.64537852486985058496168", "334.21135483324438323240341",
      "336.84185042839068479465476", "338.33999285080661188625733", "339.85821672536354019232655", "341.04226111104656048259778",
      "342.05487751036358545140383", "344.66170294025233704418119", "346.34787056600994739593646", "347.27267758442048447579709",
      "349.31626087069614412315556", "350.40841934919209918767195", "351.87864902535928043671339", "353.48890048871880678360377",
      "356.01757497726494731796036", "357.15130225203962480960293", "357.95268510163227375512892", "359.74375495311444879929199",
      "361.28936169580465039029131", "363.33133057897383474733445", "364.73602411408899371626210", "366.21271028833131686107715",
      "367.99357548174030332618330", "368.96843809573438989157690", "370.05091921210600033965116", "373.06192837211283844911940",
      "373.86487391090856974475636", "375.82591276673933410790771", "376.32409223066805211719082", "378.43668024996547972409097",
      "379.87297534653234665102406", "381.48446861718652491966252", "383.44352944953648770434576", "384.95611681486368710375158",
      "385.86130084597422918056196", "387.22289022238798097594851", "388.84612835423225460080942", "391.45608356363804577057823",
      "392.24508333951909674901518", "393.42774384443402593669895", "395.58287001099372097087771", "396.38185422259218693199945",
      "397.91873620961424338698118", "399.98511987619489950591730", "401.83922860053321653991130", "402.86191776388611417631544",
      "404.23644180020800474022780", "405.13438745990992725748627", "407.58146038689618207630900", "408.94724550235111251963404",
      "410.51386919336663864676911", "411.97226780427875066464030", "413.26273607018504688625706", "415.01880975515511564631921",
      "415.45521499629459885712878", "418.38770578953477922604572", "419.86136481815232368785231", "420.64382762504178626797465",
      "422.07671005882675962984067", "423.71657962748181861056287", "425.06988249446134761437469", "427.20882508407458052814293",
      "428.12791407661668211030507", "430.32874543093863666992698", "431.30130693070359201950512", "432.13864173458856830625325",
      "433.88921848092722530294661", "436.16100643264698407180152", "437.58169816766858115401317", "438.62173865627219629091501",
      "439.91844221437065641022179", "441.68319920118902387420444", "442.90454630260944946972310", "444.31933627755915592030574",
      "446.86062269642952252886088", "447.44170419449329006552693", "449.14854568502330475302350", "450.12694578031352403004576",
      "451.40330844538879546211322", "453.98673780667791603836681", "454.97468376861678887530944", "456.32842668924605122449983",
      "457.90389306410297157469933", "459.51341528110601175400994", "460.08794442217584125533026", "462.06536727488253096383092",
      "464.05728691054828457624608", "465.67153921137109455296665", "466.57028693082625516739213", "467.43904621026163885664500",
      "469.53600455911203219181907", "470.77365547810164769011888", "472.79917466190881665829799", "473.83523234513968707380547",
      "475.60033936937578560542882", "476.76901523748452085284869", "478.07526376667096919987273", "478.94218153463482653831710",
      "481.83033937628656136668138", "482.83478279098239730655700", "483.85142721248253756018822", "485.53914812935600693002542",
      "486.52871826165124435236753", "488.38056709001744852711143", "489.66176157795613151278090", "491.39882159366300656921333",
      "493.31444158178530093636060", "493.95799780536946490958309", "495.35882882213127749683413", "496.42969621575910348391891",
      "498.58078242968654201667508", "500.30908494169049553930939", "501.60444696514547766333255", "502.27627032711823317539951",
      "504.49977331342773718379126", "505.41523174224444202955217", "506.46415270952353122152607", "508.80070033646782080946967",
      "510.26422794367283442077952", "511.56228970037459546045490", "512.62314453140741866710125", "513.66898555547368343624415",
      "515.43505716729937724967689", "517.58966857246742534135797", "518.23422314755014357385827", "520.10631041172325590319615",
      "521.52519344949204096773240", "522.45669617773021043014441", "523.96053089201584048700751", "525.07738568727962218059122",
      "527.90364160127234522961727", "528.40621385229265894160890", "529.80622631870690079816398", "530.86691788396108964438743",
      "532.68818302829373050512645", "533.77963075376873256548255", "535.66431407587322461704612", "537.06975908312232758838974",
      "538.42852617624796284350096", "540.21316637622813338364567", "540.63139024729511736012808", "541.84743712120128154711911",
      "544.32389010100526290312131", "545.63683324893481825485544", "547.01091205812229246365588", "547.93161336448933831045116",
      "549.49756756266137845998473", "550.97001003948388904565723", "552.04957220056489279257670", "553.76497211915881461714978",
      "555.79202056168250841657322", "556.89947640685535126196422", "557.56465917205852840852399", "559.31623702868216376093514",
      "560.24080749729566824179328", "562.55920761604585110813792", "564.16087911078611781387953", "564.50605593814983512224597",
      "566.69878768280795624151228", "567.73175790117693745033473", "568.92395517962936849675349", "570.05111478246359203852702",
      "572.41998413245276404527693", "573.61461052675812998724603", "575.09388601449488560745717", "575.80724714092878070942933",
      "577.03900347209821121663709", "579.09883467203660743128436", "580.13695936238462867271628", "581.94657626590162555150611",
      "583.23608821916727826196057", "584.56170590346552836694589", "585.98456320498830057418726", "586.74277189125015564477185",
      "588.13966326624795641755424", "590.66039751676527563103200", "591.72585806504805664922245", "592.57135830022556982077272",
      "593.97471468223102924380517", "595.72815369738894917702092", "596.36276832839368408957910", "598.49307734616475440106358",
      "599.54564036436485399751540", "601.60213673593263605173811", "602.57916788638735429882272", "603.62561890357916067224397",
      "604.61621849375323291463960", "606.38346042210904108867431", "608.41321731118732517512672", "609.38957515472008052732388",
      "610.83916293773940692670254", "611.77420962088720463516836", "613.59977867563711940518646", "614.64623787223262152555308",
      "615.53856336940702785347427", "618.11283136644237338254023", "619.18448259795363424902815", "620.27289367222752191908557",
      "621.70929452794862295729863", "622.37500273977900921788154", "624.26990001817788083477295", "626.01928342765438219833622",
      "627.26839685078302075199765", "628.32586235946036193594382", "630.47388743829204587060659", "630.80578092719753264187173",
      "632.22514116711595195215471", "633.54685825225177748419713", "635.52380031060545381052558", "637.39719315983730717374807",
      "637.92551398082258109342884", "638.92793826685677019377269", "640.69479466882566762318754", "641.94549966570529454537854",
      "643.27888378139788936114336", "644.99057822974800251244371", "646.34819159550159203388094", "647.76175300428888379376681",
      "648.78640088878244077108013", "650.19751934525645908325390", "650.66868389139598253056063", "653.64957160539469190208686",
      "654.30192058631934227547062", "655.70946302235563631602674", "656.96408459946061742286990", "658.17561441860539974487981",
      "659.66384597296410783116518", "660.71673259527927005215888", "662.29658643110041064437827", "664.24460465227301344989026",
      "665.34276309559904054278817", "666.51514770417296054877510", "667.14849489455542994106921", "668.97584882023513140619228",
      "670.32358520586258403442955", "672.45818358416973418136509", "673.04357828614764577013104", "674.35589781012316789615632",
      "676.13967436362674820317814", "677.23018066876397324785480", "677.80044474622133491893876", "679.74219788252821771952594",
      "681.89499153315188910945241", "682.60273501975054548754084", "684.01354981386950523619413", "684.97262986209845254573666",
      "686.16322358772794960347301", "687.96154318470364848279634", "689.36894136227236842325519", "690.47473503235039769394309",
      "692.45168441552084884984665", "693.17697006060182484562310", "694.53390869987314001563070", "695.72633592092673016780143",
      "696.62606990034561497090282", "699.13209547601350671081617", "700.29673913214349456801215", "701.30174295464615568517391",
      "702.22734314576050011943532", "704.03383929552530932265307", "705.12581395461922766686748", "706.18465479951791902581099",
      "708.26907088510989999526903", "709.22958857028430070903469", "711.13027417968543156547486", "711.90028991437531203891508",
      "712.74938347010129025461057", "714.08277182066939307692453", "716.11239645405211014818203", "717.48256970310019071444190",
      "718.74278654548589398844918", "719.69710098836566513269096", "721.35116221853641712838616", "722.27750497567423734037614",
      "723.84582104512841551167192", "724.56261389037907959224622", "727.05640323004938161764841", "728.40548158893406003474436",
      "728.75874979561426856613063", "730.41648212275643470994404", "731.41735491859852508074936", "732.81805271449984920856753",
      "734.78964325237799425231251", "735.76545920857832107693219", "737.05292891226530804231054", "738.58042117137382252170545",
      "739.90952367404194402970096", "740.57380744729501051503597", "741.75733557294167327586116", "743.89501314247365938155015",
      "745.34498955061187432564055", "746.49930589943232950960501", "747.67456362426952835956937", "748.24275446508454786850329",
      "750.65595036212429986680744", "750.96638106665083726845842", "752.88762156720237474950771", "754.32237047171267268510309",
      "755.83930897603782987279244", "756.76824843995093072013321", "758.10172924641258341148977", "758.90023822489237476743539",
      "760.28236698351206453186960", "762.70003324969105472806900", "763.59306617283722299697325", "764.30752272418022173625123",
      "766.08754009983620539442246", "767.21847215553951408249941", "768.28146180650923082345667", "769.69340725262442432500665",
      "771.07083931367831632118722", "772.96161756575702433782917", "774.11774462794050740214191", "775.04784709658050805001699",
      "775.99971196317144247773158", "777.29974852959256481651098", "779.15707694918900406392454", "780.34892500418167053812778",
      "782.13766439081209475431769", "782.59794394607353986616651", "784.28882261246550146314610", "785.73908970071505184064619",
      "786.46114745050627745989679", "787.46846381591003838147350", "790.05909236411956429494600", "790.83162046792103501908293",
      "792.42770760860452686639107", "792.88865256262258804224275", "794.48379186989316448131838", "795.60659615616241262791256",
      "797.26347003803558491619170", "798.70757016629621130969195", "799.65433621089763277282689", "801.60424646298205596667662",
      "802.54198487841814966241714", "803.24309620427019419022623", "804.76223911266176395159578", "805.86163566709480283680319",
      "808.15181493599374739235586", "809.19778336330071038771960", "810.08180488640709989152473", "811.18435884650626033788433",
      "812.77110838910934271980129", "814.04591360751099350196760", "814.87053962587256778401969", "816.72773771439471631650257",
      "818.38066886636167651158678", "819.20464217082386260582404", "820.72189844386928746643102", "821.71345413337940180987603",
      "822.19775749340427714358186", "824.52629387162974816376648", "826.03928737657438354801416", "826.90581095408077197966445",
      "828.34017430048990037050422", "829.43701096830933362304759", "830.89588405331740073007862", "831.79977765907058307432461",
      "833.00364090915419953831125", "834.65191514782557580734534", "836.69357618759186716887034", "837.34733505953151476748642",
      "838.24902199273214583654710", "839.46539481028247555031030", "841.03638982901342372441148", "842.04135420652637133336770",
      "844.16619660735076882134610", "844.80599397576372688128478", "846.19476992769399776366252", "847.97171763951200663632758",
      "848.48928118094352382488673", "849.86227434869782626434471", "850.64544846600409237824205", "853.16311258338915532583947",
      "854.09551171986905862001822", "855.28671024440493634822844", "856.48411749079166285403492", "857.31074060260382603296423",
      "858.90402646647569441282957", "860.41067089601467075159414", "861.17109821271533760597511", "863.18971977190893423611013",
      "864.34082393006954085568750", "865.59466432651596539510688", "866.42373990404264146297959", "867.69312261178500623876853",
      "868.67049422913159666783827", "870.84690232575401620579528", "872.18875082161320775587323", "873.09897897128198149832540",
      "873.90838923533753043962999", "875.98528510878032237439244", "876.60082583302744239724313", "877.65469834103347514402209",
      "879.38095196979098245646180", "880.83464884793939028303229", "882.38669662719646125238465", "883.43033183870164568456834",
      "884.19874311459472696038428", "885.27230447961712705119809", "886.85280196291629837203333", "888.47556667381719477372639",
      "889.73529429409073709741219", "890.81313211252806368619592", "892.38643326015586934174100", "893.11911756729425833617554",
      "894.88629232086871614219290", "895.39791967478296505539686", "896.63225155620272003352659", "899.22152266838341939009564",
      "899.85888460793748344426586", "900.84973986052139611782464", "902.24320758675228846164045", "903.09967444263045494666505",
      "904.70290272228132077432409", "905.82994075822220940483941", "907.65672946896752531155671", "908.33354364506092528070820",
      "910.18633405717984256535255", "911.23495148595550409259750", "912.33104560003558724880717", "912.82399924674339537799222",
      "914.73009695837561333837524", "916.35500080864276589142084", "917.82537757042678302648396", "918.83653524352902957124898",
      "919.44834443968230478176513", "921.15639550715485336739941", "922.50062930663677026624533", "923.28571980242224267394310",
      "924.77348393347666441624646", "926.55155278460302894159238", "927.85085898575359414787096", "928.66365932893489228875629",
      "929.87409285064775477710607", "931.00921133662807295427617", "931.85274074552007992168634", "934.38530683725846475441454",
      "934.99542486384645961760974", "936.22864937928292721371866", "937.53292571197038127291623", "939.02430089921838218421842",
      "939.66094061452816598560075", "941.15699964204237260777100", "942.05234164337549787438995", "944.18803580957274451197850",
      "945.33356250304594614154224", "946.76584220472785115673217", "947.07918309625487796511947", "948.34664625504496716660509",
      "950.15161268464384086474681", "951.03324873382350997449941", "952.72798861985062608466752", "954.12971926955141533675801",
      "954.82930893821663711951376", "956.67547934328979602314203", "957.51005259642372246772877", "958.41459339013618097000400",
      "959.45916880706811256099961", "961.66957247419275334266866", "963.18208667131144699713219", "963.56704019161227067186210",
      "965.05557962375111622492669", "966.11075481841020401872462", "967.37115376626285431516478", "968.63630190608732640808991",
      "970.12561055694117547921512", "971.07149148638572794025103", "973.18536129430119422164910", "973.87307899265359719423256",
      "974.77463506583742987530315", "976.17850242058960934418780", "976.91720211705062202141727", "978.76667153511297445402301",
      "980.57800063977441806133895", "981.28861530175896945936443", "982.39648516877897840141022", "983.57507600643132875553311",
      "985.18692865577343576952857", "986.13051511018452664937399", "986.75600840765603562177784", "988.99262237065740660736618",
      "990.22391780402797236297813", "991.37429414776150543186343", "992.72869633673265944362740", "993.21458095744295370752307",
      "994.40459057109449190002781", "996.20533616429828648352798", "997.51193475193922921102984", "998.82754713692963313051962",
      "999.79157155741294046316315", "1001.3494826377827371221033",
    ];

    // --- State
    let activeZeros, sums, termIndex, paths, colors, iteration, zoomFactor, lineThickness;
    let nonZeroActive = false;
    let customZeros = []; // User-added custom t values
    let selectedNths = []; // User-selected nth zeros (indices)
    let seriesType, speedSlider, speedVal, nonZerosToggle, dampSlider, dampVal;
    let thicknessSlider, thicknessVal, zerosInput, applyZerosBtn, customTInput, addCustomBtn;
    let nthZeroInput, addNthBtn;
    let zoomInBtn, zoomOutBtn, pauseBtn, restartBtn, resetBtn, reset3DBtn;
    let isPaused = false;
    let fractionModeToggle, fractionReal, fractionStart, fractionEnd, fractionIncrement;
    let fractionControls, applyFractionBtn;
    let mode3DToggle, mode3D = false;
    let rotationX = -0.3, rotationZ = 0; // 3D camera rotation
    let showRotationToggle, showRotationPanel = false;
    let opacitySlider, opacityVal, lineOpacity = 0.8;
    let endpointSlider, endpointVal, endpointSize = 1;
    let boldZerosToggle, boldZeros = false;
    let flipViewToggle, flipView = false;
    let zAxisMode;
    let cumulativeDistances = []; // Track distance traveled for each zero
    let camDistance = 800; // Camera distance for 3D
    let camRotationY = 0, camRotationX = 0; // Camera angles
    let zScale = 1.0; // Scale factor for z-axis normalization

    const referenceCircles = [
      {
        radius: Math.sqrt(2) * 100,
        label: '√2',
        labelAngle: -0.35,
        hue: 210,
        saturation: 60,
        brightness: 85,
        alpha2D: 40,
        alpha3D: 35,
        dash: [6, 8]
      },
      {
        radius: Math.sqrt(3) * 100,
        label: '√3',
        labelAngle: -0.18,
        hue: 30,
        saturation: 65,
        brightness: 85,
        alpha2D: 40,
        alpha3D: 35,
        dash: [6, 8]
      },
      {
        radius: 2 * Math.PI * 10,
        label: '20π',
        labelAngle: -0.25,
        hue: 45,
        saturation: 70,
        brightness: 90,
        alpha2D: 40,
        alpha3D: 35,
        dash: [4, 6]
      },
      {
        radius: Math.sqrt(5) * 100,
        label: '√5',
        labelAngle: -0.05,
        hue: 120,
        saturation: 60,
        brightness: 80,
        alpha2D: 40,
        alpha3D: 35,
        dash: [6, 8]
      },
      {
        radius: Math.sqrt(7) * 100,
        label: '√7',
        labelAngle: 0.25,
        hue: 300,
        saturation: 55,
        brightness: 85,
        alpha2D: 40,
        alpha3D: 35,
        dash: [6, 8]
      }
    ];

    // Caching state for performance
    let isPrecomputing = false;
    let precomputeTarget = 1000; // How many iterations to precompute
    let isPrecomputed = false; // Flag if paths are fully cached
    let precomputeSlider, precomputeVal, precomputeBtn;

    // --- Rotation tracking
    let angles = [];           // Current angle for each zero
    let prevAngles = [];       // Previous angle for each zero
    let totalRotations = [];   // Cumulative rotations (in full turns)
    let angularVelocities = [];// Angular velocity in radians per term (smoothed)
    let angleHistory = [];     // Recent angle deltas for smoothing

    // --- Setup
    function setup() {
      createCanvas(900, 900);
      colorMode(HSB, 360, 100, 100);

      // hook up controls
      speedSlider = select('#speedSlider');
      speedVal = select('#speedVal');
      seriesType = select('#seriesType');
      seriesType.changed(initState);
      nonZerosToggle = select('#nonZerosToggle');
      dampSlider = select('#dampSlider');
      dampVal = select('#dampVal');
      thicknessSlider = select('#thicknessSlider');
      thicknessVal = select('#thicknessVal');
      zerosInput = select('#zerosInput');
      applyZerosBtn = select('#applyZerosBtn');
      customTInput = select('#customTInput');
      addCustomBtn = select('#addCustomBtn');
      nthZeroInput = select('#nthZeroInput');
      addNthBtn = select('#addNthBtn');
      zoomInBtn = select('#zoomInBtn');
      zoomOutBtn = select('#zoomOutBtn');
      pauseBtn = select('#pauseBtn');
      restartBtn = select('#restartBtn');
      resetBtn = select('#resetBtn');
      reset3DBtn = select('#reset3DBtn');
      normalizeZBtn = select('#normalizeZBtn');
      precomputeSlider = select('#precomputeSlider');
      precomputeVal = select('#precomputeVal');
      precomputeBtn = select('#precomputeBtn');
      fractionModeToggle = select('#fractionModeToggle');
      fractionReal = select('#fractionReal');
      fractionStart = select('#fractionStart');
      fractionEnd = select('#fractionEnd');
      fractionIncrement = select('#fractionIncrement');
      fractionControls = select('#fractionControls');
      applyFractionBtn = select('#applyFractionBtn');
      mode3DToggle = select('#mode3DToggle');
      zAxisMode = select('#zAxisMode');
      boldZerosToggle = select('#boldZerosToggle');
      flipViewToggle = select('#flipViewToggle');
      showRotationToggle = select('#showRotationToggle');
      opacitySlider = select('#opacitySlider');
      opacityVal = select('#opacityVal');
      endpointSlider = select('#endpointSlider');
      endpointVal = select('#endpointVal');

      speedSlider.input(() => {
        speedVal.html(speedSlider.value());
        frameRate(Number(speedSlider.value()));
      });
      dampSlider.input(() => {
        dampVal.html(Number(dampSlider.value()).toFixed(4));
      });
      thicknessSlider.input(() => {
        lineThickness = Number(thicknessSlider.value());
        thicknessVal.html(lineThickness.toFixed(2));
      });
      opacitySlider.input(() => {
        lineOpacity = Number(opacitySlider.value());
        opacityVal.html(lineOpacity.toFixed(2));
      });
      endpointSlider.input(() => {
        endpointSize = Number(endpointSlider.value());
        endpointVal.html(endpointSize.toFixed(1));
      });

      flipViewToggle.changed(() => {
        flipView = flipViewToggle.elt.checked;
      });

      precomputeSlider.input(() => {
        precomputeTarget = Number(precomputeSlider.value());
        precomputeVal.html(precomputeTarget.toString());
      });

      precomputeBtn.mousePressed(() => {
        if (!isPrecomputing) {
          isPrecomputing = true;
          precomputeBtn.html('Computing...');
          precomputeAllIterations();
        }
      });

      applyZerosBtn.mousePressed(() => {
        const n = constrain(Number(zerosInput.value()), 1, allZeroImParts.length);
        zerosInput.value(n.toString());
        initState();
      });

      nonZerosToggle.changed(() => {
        initState();
      });

      fractionModeToggle.changed(() => {
        const isChecked = fractionModeToggle.elt.checked;
        fractionControls.style('display', isChecked ? 'flex' : 'none');
        initState();
      });

      mode3DToggle.changed(() => {
        mode3D = mode3DToggle.elt.checked;

        // Show/hide 3D help text
        const help3D = document.getElementById('help3D');
        if (help3D) {
          help3D.style.display = mode3D ? 'block' : 'none';
        }

        // Recreate canvas with appropriate renderer
        let canvasElt = document.querySelector('canvas');
        if (canvasElt) canvasElt.remove();

        if (mode3D) {
          createCanvas(900, 900, WEBGL);
        } else {
          createCanvas(900, 900);
        }
        colorMode(HSB, 360, 100, 100);
      });

      boldZerosToggle.changed(() => {
        boldZeros = boldZerosToggle.elt.checked;
      });

      showRotationToggle.changed(() => {
        showRotationPanel = showRotationToggle.elt.checked;
        const panel = document.getElementById('rotationPanel');
        if (panel) {
          panel.style.display = showRotationPanel ? 'block' : 'none';
        }
      });

      applyFractionBtn.mousePressed(() => {
        initState();
      });

      // Allow Enter key to apply fraction range
      const fractionInputs = [fractionReal, fractionStart, fractionEnd, fractionIncrement];
      fractionInputs.forEach(input => {
        input.elt.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') applyFractionBtn.elt.click();
        });
      });

      addCustomBtn.mousePressed(() => {
        const tVal = customTInput.value().trim();
        if (tVal) {
          try {
            // Validate it's a number
            const test = new Big(tVal);
            customZeros.push(tVal);
            customTInput.value('');
            initState();
          } catch (e) {
            alert('Invalid number format. Please enter a valid decimal number.');
          }
        }
      });

      // Allow Enter key to add custom zero
      customTInput.elt.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          addCustomBtn.elt.click();
        }
      });

      addNthBtn.mousePressed(() => {
        const n = Number(nthZeroInput.value());
        if (n >= 1 && n <= allZeroImParts.length) {
          if (!selectedNths.includes(n)) {
            selectedNths.push(n);
            nthZeroInput.value('');
            initState();
          } else {
            alert(`The ${n}th zero is already added.`);
          }
        } else {
          alert(`Please enter a number between 1 and ${allZeroImParts.length}.`);
        }
      });

      // Allow Enter key to add nth zero
      nthZeroInput.elt.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          addNthBtn.elt.click();
        }
      });

      zoomInBtn.mousePressed(() => zoomFactor *= 1.2);
      zoomOutBtn.mousePressed(() => zoomFactor /= 1.2);

      pauseBtn.mousePressed(() => {
        isPaused = !isPaused;
        if (isPaused) {
          noLoop();
          pauseBtn.html('Resume');
        } else {
          loop();
          pauseBtn.html('Pause');
        }
      });

      restartBtn.mousePressed(() => {
        iteration = 0;
        isPrecomputed = false;
        precomputeBtn.html('Cache All');
        if (isPaused) {
          isPaused = false;
          pauseBtn.html('Pause');
          loop();
        }
        initState();
      });

      resetBtn.mousePressed(() => {
        customZeros = [];
        selectedNths = [];
        initState();
      });
      reset3DBtn.mousePressed(() => {
        camDistance = 800;
        // Reset camera by recreating canvas
        if (mode3D) {
          let canvasElt = document.querySelector('canvas');
          if (canvasElt) canvasElt.remove();
          createCanvas(900, 900, WEBGL);
          colorMode(HSB, 360, 100, 100);
        }
      });

      normalizeZBtn.mousePressed(() => {
        if (mode3D) {
          let maxZ = 0;
          for (let z = 0; z < activeZeros.length; z++) {
            const pts = paths[z];
            for (let i = 0; i < pts.length; i++) {
              if (pts[i].z > maxZ) maxZ = pts[i].z;
            }
          }
          if (maxZ > 0) {
            zScale = 400 / maxZ;
            console.log(`Z-axis normalized: maxZ=${maxZ.toFixed(1)}, scale=${zScale.toFixed(4)}`);
          }
        }
      });

      // initialize readings
      speedVal.html(speedSlider.value());
      dampVal.html(Number(dampSlider.value()).toFixed(4));
      lineThickness = Number(thicknessSlider.value());
      thicknessVal.html(lineThickness.toFixed(2));
      lineOpacity = Number(opacitySlider.value());
      opacityVal.html(lineOpacity.toFixed(2));
      endpointSize = Number(endpointSlider.value());
      endpointVal.html(endpointSize.toFixed(1));
      frameRate(Number(speedSlider.value()));

      initState();
    }

    function initState() {
      const numZeros = constrain(Number(zerosInput.value()), 1, allZeroImParts.length);
      nonZeroActive = nonZerosToggle?.elt?.checked || false;
      const fractionMode = fractionModeToggle?.elt?.checked || false;

      // Build active zeros array
      activeZeros = [];

      // Fraction mode: generate evenly-spaced imaginary values
      if (fractionMode) {
        const realPart = Number(fractionReal.value());
        const start = Number(fractionStart.value());
        const end = Number(fractionEnd.value());
        const increment = Number(fractionIncrement.value());

        if (start >= 0 && end > start && increment > 0) {
          let t = start;
          let index = 1;
          while (t <= end) {
            activeZeros.push({
              re: new Big(realPart),
              im: new Big(t),
              isZero: false, // These aren't actual zeros unless re=0.5 and t is a zero
              label: `s=${realPart.toFixed(2)}+${t.toFixed(2)}i`,
              isFraction: true
            });
            t += increment;
            index++;
          }
        }
      }

      // Add preset zeros if bulk mode is enabled (works alongside fraction mode)
      if (numZeros > 0 && selectedNths.length === 0) {
        for (let i = 0; i < numZeros; i++) {
          // Parse as string to preserve full precision
          const imPart = typeof allZeroImParts[i] === 'string' ? allZeroImParts[i] : String(allZeroImParts[i]);
          activeZeros.push({
            re: new Big(0.5),
            im: new Big(imPart),
            isZero: true,
            label: `#${i+1}`,
            nthIndex: i+1
          });
        }
      }

      // Add selected nth zeros (takes precedence over bulk mode)
      for (let i = 0; i < selectedNths.length; i++) {
        const n = selectedNths[i];
        const imPart = typeof allZeroImParts[n-1] === 'string' ? allZeroImParts[n-1] : String(allZeroImParts[n-1]);
        activeZeros.push({
          re: new Big(0.5),
          im: new Big(imPart),
          isZero: true,
          label: `#${n}`,
          isNth: true,
          nthIndex: n
        });
      }

      // Add custom zeros
      for (let i = 0; i < customZeros.length; i++) {
        activeZeros.push({
          re: new Big(0.5),
          im: new Big(customZeros[i]),
          isZero: true,
          label: `custom`,
          isCustom: true
        });
      }

      // Add non-zeros if enabled
      if (nonZeroActive) {
        for (let i = 0; i < nonZeroImParts.length; i++) {
          activeZeros.push({
            re: new Big(0.5),
            im: new Big(nonZeroImParts[i]),
            isZero: false,
            label: 'non-zero'
          });
        }
      }

      const lambda = Number(dampSlider?.value() || 0);
      const first = Math.exp(-lambda); // n = 1 term with optional Abel damping
      sums = activeZeros.map(() => ({ re: new Big(first), im: new Big(0) }));
      termIndex = activeZeros.map(() => 2); // start at n = 2
      paths = activeZeros.map(() => []);    // cached vertices per zero
      colors = makePalette(activeZeros.length, nonZeroActive ? numZeros : 0);
      iteration = 0;
      zoomFactor = 1;

      // Initialize rotation tracking
      angles = activeZeros.map(() => 0);
      prevAngles = activeZeros.map(() => 0);
      totalRotations = activeZeros.map(() => 0);
      angularVelocities = activeZeros.map(() => 0);
      angleHistory = activeZeros.map(() => []);

      // Initialize distance tracking
      cumulativeDistances = activeZeros.map(() => 0);
      
      // Reset precompute state
      isPrecomputed = false;
      isPrecomputing = false;
      if (precomputeBtn) precomputeBtn.html('Cache All');

      // Try to load cached computation from localStorage
      tryLoadCache();
    }

    // --- localStorage caching functions
    function getCacheKey() {
      // Create unique key based on active zeros configuration
      const zeroIds = activeZeros.map(z => z.im.toString()).join(',');
      return `zetaCache_${zeroIds}`;
    }

    function tryLoadCache() {
      try {
        const cacheKey = getCacheKey();
        const cached = localStorage.getItem(cacheKey);

        if (cached) {
          const data = JSON.parse(cached);
          console.log(`Loading cached computation: ${data.iterations} iterations for ${data.numZeros} zeros`);

          // Restore paths
          paths = data.paths.map(pathData =>
            pathData.map(pt => ({
              x: pt.x,
              y: pt.y,
              z: pt.z || 0
            }))
          );

          // Restore other state
          termIndex = data.termIndex;
          cumulativeDistances = data.cumulativeDistances;
          iteration = data.iterations;

          isPrecomputed = true;
          if (precomputeBtn) precomputeBtn.html('Loaded ✓');

          console.log(`Cache loaded: ${iteration} iterations restored`);
        }
      } catch (e) {
        console.warn('Failed to load cache:', e);
      }
    }

    function saveCache() {
      try {
        const cacheKey = getCacheKey();
        const data = {
          iterations: iteration,
          numZeros: activeZeros.length,
          paths: paths,
          termIndex: termIndex,
          cumulativeDistances: cumulativeDistances,
          timestamp: Date.now()
        };

        const json = JSON.stringify(data);

        // Check if storage quota exceeded (typical limit is 5-10MB)
        if (json.length > 9000000) { // ~9MB limit for safety
          console.warn('Cache too large to save, skipping');
          return;
        }

        localStorage.setItem(cacheKey, json);
        console.log(`Cache saved: ${iteration} iterations, ${(json.length / 1024).toFixed(1)} KB`);
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          console.warn('Storage quota exceeded, clearing old caches');
          clearOldCaches();
        } else {
          console.warn('Failed to save cache:', e);
        }
      }
    }

    function clearOldCaches() {
      // Clear old zeta caches to free up space
      const keys = Object.keys(localStorage);
      for (const key of keys) {
        if (key.startsWith('zetaCache_')) {
          localStorage.removeItem(key);
        }
      }
      console.log('Old caches cleared');
    }

    function makePalette(n, numZeros = 0) {
      // Color zeros based on their t-value (imaginary part)
      // nth-selected zeros, custom zeros, and fraction mode get special highlighting
      const arr = [];
      const fractionMode = fractionModeToggle?.elt?.checked || false;
      const numFraction = fractionMode ? activeZeros.filter(z => z.isFraction).length : 0;
      const numPresetZeros = (selectedNths.length === 0 && !fractionMode) ? numZeros : 0;
      const numNth = selectedNths.length;
      const numCustom = customZeros.length;

      // Find min and max t-values for color mapping
      let minT = Infinity, maxT = -Infinity;
      for (let i = 0; i < activeZeros.length; i++) {
        const t = Number(activeZeros[i].im);
        if (t < minT) minT = t;
        if (t > maxT) maxT = t;
      }

      for (let i = 0; i < n; i++) {
        // Map t-value to hue (0-360)
        const t = Number(activeZeros[i].im);
        const hue = maxT > minT ? ((t - minT) / (maxT - minT)) * 360 : (i * (360 / n)) % 360;

        // Fraction mode values: bright gradient colors
        if (fractionMode && i < numFraction) {
          arr.push(color(hue, 90, 85)); // vivid for fraction mode
        }
        // nth-selected zeros: ultra-bright, easy to identify
        else if (i >= numFraction && i < numFraction + numNth) {
          arr.push(color(hue, 100, 90)); // ultra-vivid for nth selected
        }
        // Custom zeros: bright, high saturation, maximal brightness
        else if (i >= numFraction + numNth && i < numFraction + numNth + numCustom) {
          arr.push(color(hue, 100, 95)); // ultra-vivid for custom
        }
        // Non-zeros get different styling: gray-ish with lower saturation
        else if (numZeros > 0 && i >= numFraction + numNth + numCustom) {
          arr.push(color(hue, 30, 50)); // desaturated, darker
        }
        // Regular preset zeros: color based on t-value
        else {
          arr.push(color(hue, 80, 70)); // vivid colors for actual zeros
        }
      }
      return arr;
    }

    // --- Precompute all iterations for instant replay
    function precomputeAllIterations() {
      const startTime = performance.now();
      const targetIter = precomputeTarget;
      
      console.log(`Precomputing ${targetIter} iterations for ${activeZeros.length} zeros...`);
      
      // Compute all iterations at once
      for (let iter = iteration; iter < targetIter; iter++) {
        for (let z = 0; z < activeZeros.length; z++) {
          stepOne(z);
        }
        iteration++;
        
        // Update progress every 100 iterations
        if (iter % 100 === 0) {
          precomputeBtn.html(`${Math.round((iter / targetIter) * 100)}%`);
        }
      }
      
      const elapsed = performance.now() - startTime;
      console.log(`Precomputed ${targetIter} iterations in ${(elapsed / 1000).toFixed(2)}s`);

      isPrecomputed = true;
      isPrecomputing = false;
      precomputeBtn.html('Cached ✓');

      // Save to localStorage for future sessions
      saveCache();

      // Reset iteration to replay from cache
      iteration = 0;
    }

    // --- Animation
    function draw() {
      background(255);

      if (mode3D) {
        draw3D();
      } else {
        draw2D();
      }

      // Update rotation panel every 10 iterations to reduce overhead (only if visible)
      if (showRotationPanel && iteration % 10 === 0) {
        updateRotationPanel();
      }

      iteration++;
    }

    function draw2D() {
      push();
      translate(width / 2, height / 2);
      scale(zoomFactor);
      if (flipView) scale(-1, -1);

      // axes
      stroke(0, 0, 0, 40);
      strokeWeight(1 / zoomFactor);
      line(-width, 0, width, 0);
      line(0, -height, 0, height);

      drawReferenceCircle2D();

      // step once for each zero; append point; then draw
      for (let z = 0; z < activeZeros.length; z++) {
        // Only compute new steps if not replaying from cache
        if (!isPrecomputed && termIndex[z] - 2 < precomputeTarget) {
          stepOne(z);            // advance one term & push a new vertex
        }
        drawPath2D(z);         // draw cached polyline
        drawEndpoint2D(z);     // draw current endpoint
      }

      pop();

      drawReferenceCircleLabels2D();
      drawHUD();
    }

    function drawReferenceCircle2D() {
      push();
      noFill();
      strokeWeight(1 / zoomFactor);
      const ctx = drawingContext;
      for (let i = 0; i < referenceCircles.length; i++) {
        const circle = referenceCircles[i];
        stroke(circle.hue, circle.saturation, circle.brightness, circle.alpha2D);
        const diameter = circle.radius * 2;
        if (ctx && ctx.setLineDash) {
          ctx.save();
          ctx.setLineDash(circle.dash);
          ellipse(0, 0, diameter, diameter);
          ctx.restore();
        } else {
          const segments = 180;
          for (let seg = 0; seg < segments; seg += 2) {
            const a1 = (seg / segments) * TWO_PI;
            const a2 = ((seg + 1) / segments) * TWO_PI;
            arc(0, 0, diameter, diameter, a1, a2);
          }
        }
      }
      pop();
    }

    function drawReferenceCircleLabels2D() {
      if (mode3D) return;
      push();
      noStroke();
      textAlign(CENTER, CENTER);
      for (let i = 0; i < referenceCircles.length; i++) {
        const circle = referenceCircles[i];
        fill(circle.hue, circle.saturation, circle.brightness, 80);
        const radius = circle.radius + 10;
        const angle = circle.labelAngle + (flipView ? Math.PI : 0);
        const screenX = width / 2 + Math.cos(angle) * radius * zoomFactor;
        const screenY = height / 2 + Math.sin(angle) * radius * zoomFactor;
        const size = 13;
        textSize(size);
        text(circle.label, screenX, screenY);
      }
      pop();
    }

    function draw3D() {
      // Enhanced camera controls - full 360° rotation
      // Mouse drag for rotation (built-in p5.js orbitControl)
      // Parameters: (rotateX sensitivity, rotateY sensitivity, zoom sensitivity)
      orbitControl(3, 3, 0.2); // Increased sensitivity for smoother rotation

      push();
      if (flipView) {
        rotateY(Math.PI);
        rotateZ(Math.PI);
      }

      // Draw axes in 3D
      push();
      strokeWeight(2);
      // X axis (red)
      stroke(255, 0, 0);
      line(-400, 0, 0, 400, 0, 0);
      // Y axis (green)
      stroke(0, 255, 0);
      line(0, -400, 0, 0, 400, 0);
      // Z axis (blue) - length depends on mode
      stroke(0, 0, 255);
      const mode = zAxisMode?.value() || 'iteration';
      let maxZ;
      if (mode === 'distance' && cumulativeDistances.length > 0) {
        // Use max distance traveled
        maxZ = Math.max(...cumulativeDistances, 100);
      } else {
        // Use iteration-based
        maxZ = iteration * 2;
      }
      line(0, 0, 0, 0, 0, maxZ * zScale);
      pop();

      drawReferenceCircle3D();

      // step once for each zero; append point; then draw
      for (let z = 0; z < activeZeros.length; z++) {
        // Only compute new steps if not replaying from cache
        if (!isPrecomputed && termIndex[z] - 2 < precomputeTarget) {
          stepOne(z);            // advance one term & push a new vertex
        }
        drawPath3D(z);         // draw cached 3D polyline
      }

      pop();
    }

    function drawReferenceCircle3D() {
      if (!mode3D) return;
      const segments = 120;
      const dotSize = 6;
      for (let i = 0; i < referenceCircles.length; i++) {
        const circle = referenceCircles[i];
        push();
        noStroke();
        fill(circle.hue, circle.saturation, circle.brightness, circle.alpha3D);
        for (let seg = 0; seg < segments; seg++) {
          if (seg % 2 === 1) continue; // skip every other to mimic dots
          const angle = (seg / segments) * TWO_PI;
          const x = Math.cos(angle) * circle.radius;
          const y = Math.sin(angle) * circle.radius;
          push();
          translate(x, y, 0);
          box(dotSize, dotSize, 1);
          pop();
        }
        pop();
      }
    }

    // Mouse wheel zoom for 3D mode
    function mouseWheel(event) {
      if (mode3D) {
        // Adjust camera distance based on scroll
        camDistance += event.delta * 0.5;
        camDistance = constrain(camDistance, 200, 3000);
        return false; // Prevent page scroll
      }
    }

    // Keyboard controls for 3D navigation
    function keyPressed() {
      if (!mode3D) return;

      // Arrow keys for manual rotation (when not dragging)
      if (keyCode === UP_ARROW) {
        camRotationX -= 0.05;
        return false;
      } else if (keyCode === DOWN_ARROW) {
        camRotationX += 0.05;
        return false;
      } else if (keyCode === LEFT_ARROW) {
        camRotationY -= 0.05;
        return false;
      } else if (keyCode === RIGHT_ARROW) {
        camRotationY += 0.05;
        return false;
      }

      // +/- for zoom
      if (key === '+' || key === '=') {
        camDistance -= 50;
        camDistance = constrain(camDistance, 200, 3000);
        return false;
      } else if (key === '-' || key === '_') {
        camDistance += 50;
        camDistance = constrain(camDistance, 200, 3000);
        return false;
      }

      // 'R' to reset view
      if (key === 'r' || key === 'R') {
        reset3DBtn.elt.click();
        return false;
      }
    }

    function drawHUD() {
      // Skip in 3D mode
      if (mode3D) return;

      push();
      noStroke();
      fill(0);
      textSize(16);
      const numPresetZeros = activeZeros.filter(z => z.isZero && !z.isCustom && !z.isNth).length;
      const numNthZeros = activeZeros.filter(z => z.isNth).length;
      const numCustomZeros = activeZeros.filter(z => z.isCustom).length;
      const numFractionMode = activeZeros.filter(z => z.isFraction).length;
      const numNonZeros = activeZeros.filter(z => !z.isZero && !z.isFraction).length;

      let statusText = `Iteration n = ${iteration}`;
      if (numFractionMode > 0) {
        const realPart = Number(fractionReal.value());
        const start = Number(fractionStart.value());
        const end = Number(fractionEnd.value());
        const inc = Number(fractionIncrement.value());
        statusText += `  |  Fraction: ${numFractionMode} points (s=${realPart}+ti, t=${start}→${end}, Δ=${inc})`;
      }
      if (numPresetZeros > 0) {
        statusText += `  |  Preset: ${numPresetZeros}`;
      }
      if (numNthZeros > 0) {
        const nthList = selectedNths.sort((a,b) => a-b).join(', ');
        statusText += `  |  nth: [${nthList}]`;
      }
      if (numCustomZeros > 0) {
        statusText += `  |  Custom: ${numCustomZeros}`;
      }
      if (numNonZeros > 0) {
        statusText += `  |  Non-zeros: ${numNonZeros}`;
      }
      text(statusText, 14, height - 16);
      pop();
    }

    function updateRotationPanel() {
      const panel = document.getElementById('rotationPanel');
      if (!panel) return;

      let html = '<table><thead><tr>';
      html += '<th>Label</th>';
      html += '<th>t value</th>';
      html += '<th onclick="sortRotationTable(\'distance\')" style="cursor: pointer;">Distance ↕</th>';
      html += '<th>Total Rotations</th>';
      html += '<th>ω (rad/term)</th>';
      html += '<th>RPM (rot/100 terms)</th>';
      html += '<th>Current n</th>';
      html += '</tr></thead><tbody>';

      // Sort by nth index if available, otherwise by order
      const sortedIndices = activeZeros.map((z, i) => ({ z, i }))
        .sort((a, b) => {
          const aIdx = a.z.nthIndex || 99999;
          const bIdx = b.z.nthIndex || 99999;
          return aIdx - bIdx;
        });

      for (let j = 0; j < sortedIndices.length; j++) {
        const i = sortedIndices[j].i;
        const z = activeZeros[i];
        const rotations = totalRotations[i];
        const omega = angularVelocities[i];
        const rpm = (omega / (2 * Math.PI)) * 100; // Rotations per 100 terms
        const distance = cumulativeDistances[i] || 0;

        // Color indicator (black for zeros, colored for others)
        let colorStyle;
        if (z.isZero) {
          colorStyle = 'color: rgb(0, 0, 0); font-weight: bold';
        } else {
          colorStyle = `color: rgb(${red(colors[i])}, ${green(colors[i])}, ${blue(colors[i])})`;
        }

        html += `<tr style="${colorStyle}">`;
        html += `<td><strong>${z.label}</strong></td>`;
        html += `<td>${z.im.toFixed(6)}</td>`;
        html += `<td>${distance > 0 ? distance.toFixed(4) : '0.0000'}</td>`;
        html += `<td>${rotations.toFixed(3)}</td>`;
        html += `<td>${omega.toFixed(6)}</td>`;
        html += `<td>${rpm.toFixed(4)}</td>`;
        html += `<td>${termIndex[i] - 1}</td>`;
        html += '</tr>';
      }

      html += '</tbody></table>';
      html += '<div style="margin-top: 8px; font-size: 11px; color: #666;">💡 Click "Distance ↕" to sort by distance traveled. Conjecture: Zeta zeros should have the lowest values.</div>';
      panel.innerHTML = html;
    }

    // Global function for sorting rotation table
    window.sortRotationTable = function(sortBy) {
      if (sortBy === 'distance') {
        // Create sorted list
        const sorted = activeZeros.map((z, i) => ({
          z, i, distance: cumulativeDistances[i] || 0
        })).sort((a, b) => a.distance - b.distance);

        // Rebuild table manually
        const panel = document.getElementById('rotationPanel');
        if (!panel) return;

        let html = '<table><thead><tr>';
        html += '<th>Zero</th>';
        html += '<th>t value</th>';
        html += '<th onclick="sortRotationTable(\'distance\')">Distance ↕</th>';
        html += '<th>Total Rotations</th>';
        html += '<th>ω (rad/term)</th>';
        html += '<th>RPM (rot/100 terms)</th>';
        html += '<th>Current n</th>';
        html += '</tr></thead><tbody>';

        for (let j = 0; j < sorted.length; j++) {
          const i = sorted[j].i;
          const z = activeZeros[i];
          const rotations = totalRotations[i];
          const omega = angularVelocities[i];
          const rpm = (omega / (2 * Math.PI)) * 100;
          const distance = sorted[j].distance;

          let colorStyle;
          if (z.isZero) {
            colorStyle = 'color: rgb(0, 0, 0); font-weight: bold';
          } else {
            colorStyle = `color: rgb(${red(colors[i])}, ${green(colors[i])}, ${blue(colors[i])})`;
          }

          html += `<tr style="${colorStyle}">`;
          html += `<td><strong>${z.label}</strong></td>`;
          html += `<td>${z.im.toFixed(6)}</td>`;
          html += `<td>${distance > 0 ? distance.toFixed(4) : '0.0000'}</td>`;
          html += `<td>${rotations.toFixed(3)}</td>`;
          html += `<td>${omega.toFixed(6)}</td>`;
          html += `<td>${rpm.toFixed(4)}</td>`;
          html += `<td>${termIndex[i] - 1}</td>`;
          html += '</tr>';
        }

        html += '</tbody></table>';
        html += '<div style="margin-top: 8px; font-size: 11px; color: #666;">💡 Sorted by distance traveled (lowest first). Conjecture: Zeta zeros should cluster at the top.</div>';
        panel.innerHTML = html;
      }
    };

    // Advance one term for zero index z
    function stepOne(z) {
      const s = activeZeros[z];
      const n = termIndex[z];

      const sigma = s.re.toNumber(); // real part = 0.5
      const t = s.im.toNumber();     // imaginary part

      // Compute n^(-s) = n^(-sigma - it) = n^(-sigma) * e^(it log n)
      const amp = Math.pow(n, -sigma);  // n^(-1/2) for sigma = 0.5
      const phase = -t * Math.log(n);   // -t log(n)

      // n^(-s) = amp * (cos(phase) + i*sin(phase))
      let re = amp * Math.cos(phase);
      let im = amp * Math.sin(phase);

      // Apply prime-mask based on series type
      const p = Number(seriesType.value());
      if (p > 1) {
        const multiplier = (n % p === 0) ? (1 - p) : 1;
        re *= multiplier;
        im *= multiplier;
      }

      // optional Abel damping e^{-λ n}
      const lambda = Number(dampSlider?.value() || 0);
      if (lambda > 0) {
        const w = Math.exp(-lambda * n);
        re *= w; im *= w;
      }

      // update sum
      const sum = sums[z];
      sum.re = sum.re.plus(re);
      sum.im = sum.im.plus(im);

      // store vertex (scale factor 100 for visibility; invert y)
      const vx = sum.re.times(100).toNumber();
      const vy = sum.im.times(-100).toNumber();

      // Calculate distance traveled from previous point
      if (paths[z].length > 0) {
        const prevPt = paths[z][paths[z].length - 1];
        const dx = vx - prevPt.x;
        const dy = vy - prevPt.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        cumulativeDistances[z] += dist;
      }

      // Choose z-axis value based on mode
      const mode = zAxisMode?.value() || 'iteration';
      let vz;
      if (mode === 'distance') {
        vz = cumulativeDistances[z]; // Cumulative distance traveled
      } else {
        vz = (n - 2) * 2; // Iteration (scaled for visibility)
      }

      paths[z].push({ x: vx, y: vy, z: vz });

      // Calculate rotation tracking
      const currentAngle = Math.atan2(sum.im.toNumber(), sum.re.toNumber());

      if (n > 2) { // Skip first term
        prevAngles[z] = angles[z];
        angles[z] = currentAngle;

        // Calculate angle delta, handling 2π wraparound
        let angleDelta = angles[z] - prevAngles[z];

        // Normalize to [-π, π]
        while (angleDelta > Math.PI) angleDelta -= 2 * Math.PI;
        while (angleDelta < -Math.PI) angleDelta += 2 * Math.PI;

        // Track cumulative rotations
        totalRotations[z] += angleDelta / (2 * Math.PI);

        // Store recent angle deltas for smoothing (keep last 20)
        if (!angleHistory[z]) angleHistory[z] = [];
        angleHistory[z].push(angleDelta);
        if (angleHistory[z].length > 20) angleHistory[z].shift();

        // Calculate smoothed angular velocity (average of recent deltas)
        const avgDelta = angleHistory[z].reduce((a, b) => a + b, 0) / angleHistory[z].length;
        angularVelocities[z] = avgDelta;
      } else {
        angles[z] = currentAngle;
      }

      termIndex[z] = n + 1;
    }

    function drawPath2D(z) {
      const pts = paths[z];
      if (pts.length < 2) return;
      noFill();

      // Zeta zeros get black trails, others get their assigned color
      const isActualZero = activeZeros[z].isZero;
      if (isActualZero) {
        stroke(0, 0, 0, lineOpacity * 100); // Black with opacity
      } else {
        // Apply opacity to the stroke color
        const c = colors[z];
        const h = hue(c);
        const s = saturation(c);
        const b = brightness(c);
        stroke(h, s, b, lineOpacity * 100); // HSB alpha is 0-100
      }

      // Bold zeros: 2.5x thicker lines for actual zeta zeros
      const thicknessMultiplier = (boldZeros && isActualZero) ? 2.5 : 1;
      strokeWeight((lineThickness * thicknessMultiplier) / zoomFactor);

      // When replaying from cache, only draw up to current iteration
      const maxPoints = isPrecomputed ? Math.min(pts.length, iteration) : pts.length;

      beginShape();
      for (let i = 0; i < maxPoints; i++) {
        vertex(pts[i].x, pts[i].y);
      }
      endShape();
    }

    function drawPath3D(z) {
      const pts = paths[z];
      if (pts.length < 2) return;
      noFill();

      // Zeta zeros get black trails, others get their assigned color
      const isActualZero = activeZeros[z].isZero;
      if (isActualZero) {
        stroke(0, 0, 0, lineOpacity * 100); // Black with opacity
      } else {
        // Apply opacity to the stroke color
        const c = colors[z];
        const h = hue(c);
        const s = saturation(c);
        const b = brightness(c);
        stroke(h, s, b, lineOpacity * 100); // HSB alpha is 0-100
      }

      // Bold zeros: 2.5x thicker lines for actual zeta zeros
      const thicknessMultiplier = (boldZeros && isActualZero) ? 2.5 : 1;
      strokeWeight(lineThickness * thicknessMultiplier);

      // When replaying from cache, only draw up to current iteration
      const maxPoints = isPrecomputed ? Math.min(pts.length, iteration) : pts.length;

      beginShape();
      for (let i = 0; i < maxPoints; i++) {
        vertex(pts[i].x, pts[i].y, pts[i].z * zScale);
      }
      endShape();
    }

    function drawEndpoint2D(z) {
      if (endpointSize === 0) return; // Skip if size is 0
      const pts = paths[z];
      if (pts.length === 0) return;
      const p = pts[pts.length - 1];
      noStroke();
      fill(colors[z]);

      // Bold zeros: 2.5x larger endpoints for actual zeta zeros
      const isActualZero = activeZeros[z].isZero;
      const sizeMultiplier = (boldZeros && isActualZero) ? 2.5 : 1;
      const r = (endpointSize * sizeMultiplier) / zoomFactor;
      ellipse(p.x, p.y, r, r);

      // small label on first few to avoid clutter
      if (z < 4) {
        fill(0);
        textSize(12 / zoomFactor);
        const tStr = activeZeros[z].im.toFixed(3);
        text(`t≈${tStr}`, p.x + 8 / zoomFactor, p.y - 6 / zoomFactor);
      }
    }

    // Mouse click handler to display coordinates
    function mouseClicked() {
      // Only handle clicks on the canvas, not on UI elements
      if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) {
        return true; // Allow default behavior for UI elements
      }

      if (mode3D) {
        // 3D mode - just show screen click coordinates
        console.log(`3D Click: Screen (${mouseX}, ${mouseY})`);
        alert(`3D mode: Screen coordinates (${mouseX}, ${mouseY})\nNote: 3D world coordinates require ray casting`);
      } else {
        // 2D mode - convert screen coordinates to world coordinates
        const worldX = (mouseX - width / 2) / zoomFactor;
        const worldY = (mouseY - height / 2) / zoomFactor;
        console.log(`2D Click: World coordinates (${worldX.toFixed(3)}, ${worldY.toFixed(3)})`);
        alert(`World coordinates:\nX: ${worldX.toFixed(6)}\nY: ${worldY.toFixed(6)}`);
      }
      return false; // Prevent default behavior only for canvas clicks
    }
  </script>
</body>
</html>
